#summing it all together
rho_g <- rho_g + ((lam_r*(p_1 + p_2*p_3)) /  (m*mu_R))
p_1
p_2*p_3
sum_prob <- p_1 + p_2*p_3
sum_prob
rho_r <- 0
#probability service of restricted calls when at least one R server is free
p_1 <- (1-p_B_R)
#probability when there is a restricted queue and all servers are busy
p_2 <- (p_B_R *p_B_G)
# probability R finishes before G
R_fin <- (n*mu_G) / (m*mu_R + n*mu_G)
# probability G finishes before R
G_fin<- (m*mu_R) / (m*mu_R + n*mu_G)
#summation in ith spot in queue and R finishes before ith general servers
p_3 <- 0
for(i in 1:K){
p_3 <- p_3 + (((1-p)^(i-1))*p*R_fin*(G_fin^(i-1)))
}
#summing it all together
rho_r <- (lam_r*(p_1 + p_2*p_3)) /  (m*mu_R)
sum_prob
p_1
p_2
p_2*p_3
sum_prob <- sum_prob + p_1 + (p_2*p_3)
sum_prob
p_3
sum_prob <- sum_prob -(p_2*p_3)
sum_prob <- sum_prob +p_2
sum_prob
sum_prob <- 1- P_B_R
p_3 <- 0
for(i in 1:K){
p_3 <- p_3 + (((1-p)^(i-1))*R_fin*(G_fin^(i-1)))
}
p_3
rho_g <- 0
#service of all general customers
rho_g <- lam_g / (n*mu_G)
#probability service of restricted calls when at least one G server is free and no R server is free
p_1 <- (1-p_B_G)*p_B_R
#probability when there is a restricted queue and all servers are busy
p_2 <- (p_B_R *p_B_G)
# probability R finishes before G
R_fin <- (n*mu_G) / (m*mu_R + n*mu_G)
# probability G finishes before R
G_fin<- (m*mu_R) / (m*mu_R + n*mu_G)
#summation in ith spot in queue and R finishes before ith general servers
p_3 <- 0
for(i in 1:(K+1)){
p_3 <- p_3 + (((1-p)^(i-1))*p*(G_fin^(i)))
}
#summing it all together
rho_g <- rho_g + ((lam_r*(p_1 + p_2*p_3)) /  (m*mu_R))
rho_g <- 0
#service of all general customers
rho_g <- lam_g / (n*mu_G)
#probability service of restricted calls when at least one G server is free and no R server is free
p_1 <- (1-p_B_G)*p_B_R
#probability when there is a restricted queue and all servers are busy
p_2 <- (p_B_R *p_B_G)
# probability R finishes before G
R_fin <- (n*mu_G) / (m*mu_R + n*mu_G)
# probability G finishes before R
G_fin<- (m*mu_R) / (m*mu_R + n*mu_G)
#summation in ith spot in queue and R finishes before ith general servers
p_3 <- 0
for(i in 1:(K+1)){
p_3 <- p_3 + (((1-p)^(i-1))*(G_fin^(i)))
}
#summing it all together
rho_g <- rho_g + ((lam_r*(p_1 + p_2*p_3)) /  (m*mu_R))
p_1 + p_2*p_#
p_1 + p_2*p_3
p
p_3
K
p_3 <- 0
for(i in 1:(K+1)){
p_3 <- p_3 + (((1-p)^(i-1))*p*(G_fin^(i)))
}
p_3
p_3 <- 0
for(i in 1:(K+1)){
p_3 <- p_3 + (((1-p)^(i-1))*(G_fin^(i)))
}
p_3
source("~/GitHub/gensecqueue/R/gensecqueue.R", echo=TRUE)
devtools::load_all(".")
rm(list = c("calc_rho_r", "gensecqueue"))
devtools::load_all(".")
####### Parameters ranges <-  c(avg, min, max) #########
# Percentage of calls that require multiple response
n <- 	0.6019791
# average numer of cars in multiple response
avg_cars <-3.116467
# number of police servers
s_T <- list(400, 300, 450)
s_T <- lapply(s_T, function(x) round(x  /(avg_cars*n + (1-n))))
# TEST way lower number to see delay trends
s_T <- c(s_T,list(50, 70, 100))
# Arrival Rate (calls / hour)
lam <- list(33.798, 27.966, 41.052)
# Percentage of calls that are crisis calls
p <- list(0.0344,	0.0288,	0.039)
# Police Service Time (calls /hour)
mu_T <- list(0.582, 0.558, 0.654)
# Crisis Service Time (calls /hour)
mu_M <- list(0.588,	0.558,	0.618)
# number of crisis servers
s_M <- list(5,	3,	15)
s_police <- 50
s_crisis <- 3
s_crisis <- 5
s_crisis <- 3
K <- 100
K <- 99
mu_police <- 0.582
mu_aux<- 0.55
lambda <- 23.966
p <- 0.9656
results <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,K)
s_police<- 198
results <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,K)
s_police <- 2
s_crisis<- 1
K=2
results <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,K)
lam<- 1
lambda<- 1
results <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,K)
lambda = 2
p<- .5
lambda<- 2
s_police <- 5
s_crisis <- 2
mu_crisis <- 2
mu_police <- 2
results <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,K)
s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,K)
s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,K
paste0(AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,13))
paste0(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,13))
paste0(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,13)
paste0(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,13)
s_police <- 176
results <- AuxiliaryQueue::auxqueue(176,5,  0.582, 0.588,33.798, 0.039,13)
results <- AuxiliaryQueue::auxqueue(176,5,  0.582, 0.588,33.798, 1-0.039,13)
results
results <- AuxiliaryQueue::auxqueue(50,3,  0.582, 0.588,27.966, 1-0.039,13)
####### Parameters ranges <-  c(avg, min, max) #########
# Percentage of calls that are crisis calls
p <- list(0.0344,	0.0288,	0.039)
# Police Service Time (calls /hour)
mu_A <- list(0.582, 0.558, 0.654)
# Crisis Service Time (calls /hour)
mu_M <- list(0.588,	0.558,	0.618)
# Percentage of calls that require multiple response
n <- 	0.6019791
# average numer of cars in multiple response
avg_cars <-3.116467
# number of crisis servers - model only allows for one crisis server so we reduce the arrival rate and police vehicles by this much
s_M <- list(5,	3,	15)
# Arrival Rate (calls / hour)
lam <- list(33.798, 27.966, 41.052)
#lam <- mapply("/",lam,s_M)
# number of police servers
s_T <- list(400, 300, 450)
s_T <- lapply(s_T, function(x) round(x  /(avg_cars*n + (1-n))))
# TEST way lower number to see delay trends
s_T <- c(s_T,list(50, 70, 100))
library(hqueue)
# number of tests
N <- length(lam) * length(p) * length(mu_A) * length(mu_M) * length(s_T)*length(s_M)
xy <- vector("list", ceiling(N)) # create an empty list into which values are to be filled
i <- 1
for(lambda in lam){
for(p12 in p){
for(mu_police in mu_A){
for(mu_crisis in mu_M){
for (s_crisis in s_M){
for(s_police in s_T){
lam1 <- (lambda/s_crisis)
s_p <- round(s_police / s_crisis) # number of police per one crisis worker
lam2 <- lam1/s_p # need to divide lambda by the number of active police, due to model structure
xy[[i]] <- h_queue(s_p,lam2,p12,mu_police,mu_crisis)
xy[[i]] <- append(unlist(xy[[i]]), s_crisis)
i <- i + 1
}
}
}
}
}
}
xy <- as.data.frame(do.call(rbind, xy))
# Save results to a CSV file
output_file <- "IISE 2024 paper/PRM_1b_Results.csv"
write.csv(xy, file = output_file, row.names = FALSE)
xy
results <- AuxiliaryQueue::auxqueue(50,3,  0.582, 0.588,27.966, 1-0.039,13)
results
check_system(41.052,70,5,0.582,0.618)
check_system(41.052,70,5,0.029,0.582,0.618)
check_system(33.798,50,5,0.034,0.654,0.588)
results <- AuxiliaryQueue::auxqueue(50,5,  0.654, 0.588,33.798, 1-0.034,13)
####### Parameters ranges <-  c(avg, min, max) #########
# Percentage of calls that require multiple response
n <- 	0.6019791
# average numer of cars in multiple response
avg_cars <-3.116467
# number of police servers
s_T <- list(400, 300, 450)
s_T <- lapply(s_T, function(x) round(x  /(avg_cars*n + (1-n))))
# TEST way lower number to see delay trends
s_T <- c(s_T,list(50, 70, 100))
# Arrival Rate (calls / hour)
lam <- list(33.798, 27.966, 41.052)
# Percentage of calls that are crisis calls
p <- list(0.0344,	0.0288,	0.039)
# Police Service Time (calls /hour)
mu_T <- list(0.582, 0.558, 0.654)
# Crisis Service Time (calls /hour)
mu_M <- list(0.588,	0.558,	0.618)
# number of crisis servers
s_M <- list(5,	3,	15)
library(AuxiliaryQueue)
detach("package:AuxiliaryQueue", unload = TRUE)
install_github("vmwhite/auxqueue")
####### Parameters ranges <-  c(avg, min, max) #########
# Percentage of calls that require multiple response
n <- 	0.6019791
# average numer of cars in multiple response
avg_cars <-3.116467
# number of police servers
s_T <- list(400, 300, 450)
s_T <- lapply(s_T, function(x) round(x  /(avg_cars*n + (1-n))))
# TEST way lower number to see delay trends
s_T <- c(s_T,list(50, 70, 100))
# Arrival Rate (calls / hour)
lam <- list(33.798, 27.966, 41.052)
# Percentage of calls that are crisis calls
p <- list(0.0344,	0.0288,	0.039)
# Police Service Time (calls /hour)
mu_T <- list(0.582, 0.558, 0.654)
# Crisis Service Time (calls /hour)
mu_M <- list(0.588,	0.558,	0.618)
# number of crisis servers
s_M <- list(5,	3,	15)
# number of tests
N <- length(lam) * length(p) * length(mu_T) * length(mu_M) * length(s_T) * length(s_M)
xy_inf <- vector("list", ceiling(N)) # create an empty list into which values are to be filled
xy_max7 <- vector("list", ceiling(N)) # create an empty list into which values are to be filled
xy_max3 <- vector("list", ceiling(N)) # create an empty list into which values are to be filled
xy_max1 <- vector("list", ceiling(N)) # create an empty list into which values are to be filled
i <- 1
#append(i, lambda, mu_police, s_police, mu_crisis, s_crisis)
for(lambda in lam){
for(p12 in p){
for(mu_police in mu_T){
for(mu_crisis in mu_M){
for(s_police in s_T){
for(s_crisis in s_M){
# which function is used to
p <- 1 - p12
xy_inf[[i]] <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,13, TRUE)
xy_max7[[i]] <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,7, FALSE)
xy_max3[[i]] <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,3, FALSE)#(c_p,c_aux,mu_p, mu_aux, lambda, p, K=13)
xy_max1[[i]] <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,1, FALSE)
i <- i + 1
}
}
}
}
}
}
# number of tests
N <- length(lam) * length(p) * length(mu_T) * length(mu_M) * length(s_T) * length(s_M)
xy_inf <- vector("list", ceiling(N)) # create an empty list into which values are to be filled
xy_max7 <- vector("list", ceiling(N)) # create an empty list into which values are to be filled
xy_max3 <- vector("list", ceiling(N)) # create an empty list into which values are to be filled
xy_max1 <- vector("list", ceiling(N)) # create an empty list into which values are to be filled
i <- 1
#append(i, lambda, mu_police, s_police, mu_crisis, s_crisis)
for(lambda in lam){
for(p12 in p){
for(mu_police in mu_T){
for(mu_crisis in mu_M){
for(s_police in s_T){
for(s_crisis in s_M){
# which function is used to
p <- 1 - p12
#xy_inf[[i]] <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,13, TRUE)
xy_max7[[i]] <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,7, FALSE)
xy_max3[[i]] <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,3, FALSE)#(c_p,c_aux,mu_p, mu_aux, lambda, p, K=13)
xy_max1[[i]] <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,1, FALSE)
i <- i + 1
}
}
}
}
}
}
# number of tests
N <- length(lam) * length(p) * length(mu_T) * length(mu_M) * length(s_T) * length(s_M)
xy_inf <- vector("list", ceiling(N)) # create an empty list into which values are to be filled
xy_max7 <- vector("list", ceiling(N)) # create an empty list into which values are to be filled
xy_max3 <- vector("list", ceiling(N)) # create an empty list into which values are to be filled
xy_max1 <- vector("list", ceiling(N)) # create an empty list into which values are to be filled
i <- 1
#append(i, lambda, mu_police, s_police, mu_crisis, s_crisis)
for(lambda in lam){
for(p12 in p){
for(mu_police in mu_T){
for(mu_crisis in mu_M){
for(s_police in s_T){
for(s_crisis in s_M){
# which function is used to
p <- 1 - p12
#xy_inf[[i]] <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,13, TRUE)
xy_max7[[i]] <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,7+s_crisis, FALSE)
xy_max3[[i]] <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,3+s_crisis, FALSE)#(c_p,c_aux,mu_p, mu_aux, lambda, p, K=13)
xy_max1[[i]] <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,1+s_crisis, FALSE)
i <- i + 1
}
}
}
}
}
}
####### Parameters ranges <-  c(avg, min, max) #########
# Percentage of calls that require multiple response
n <- 	0.6019791
# average numer of cars in multiple response
avg_cars <-3.116467
# number of police servers
s_T <- list(400, 300, 450)
s_T <- lapply(s_T, function(x) round(x  /(avg_cars*n + (1-n))))
# TEST way lower number to see delay trends
s_T <- c(s_T,list(50, 70, 100))
# Arrival Rate (calls / hour)
lam <- list(33.798, 27.966, 41.052)
# Percentage of calls that are crisis calls
p <- list(0.0344,	0.0288,	0.039)
# Police Service Time (calls /hour)
mu_T <- list(0.582, 0.558, 0.654)
# Crisis Service Time (calls /hour)
mu_M <- list(0.588,	0.558,	0.618)
# number of crisis servers
s_M <- list(5,	3,	15)
####### Parameters ranges <-  c(avg, min, max) #########
# Percentage of calls that require multiple response
n <- 	0.6019791
# average numer of cars in multiple response
avg_cars <-3.116467
# number of police servers
s_T <- list(400, 300, 450)
s_T <- lapply(s_T, function(x) round(x  /(avg_cars*n + (1-n))))
# TEST way lower number to see delay trends
s_T <- c(s_T,list(50, 70, 100))
# Arrival Rate (calls / hour)
lam <- list(33.798, 27.966, 41.052)
# Percentage of calls that are crisis calls
p <- list(0.0344,	0.0288,	0.039)
# Police Service Time (calls /hour)
mu_T <- list(0.582, 0.558, 0.654)
# Crisis Service Time (calls /hour)
mu_M <- list(0.588,	0.558,	0.618)
# number of crisis servers
s_M <- list(5,	3,	15)
# number of tests
N <- length(lam) * length(p) * length(mu_T) * length(mu_M) * length(s_T) * length(s_M)
xy_inf <- vector("list", ceiling(N)) # create an empty list into which values are to be filled
xy_max7 <- vector("list", ceiling(N)) # create an empty list into which values are to be filled
xy_max3 <- vector("list", ceiling(N)) # create an empty list into which values are to be filled
xy_max1 <- vector("list", ceiling(N)) # create an empty list into which values are to be filled
i <- 1
#append(i, lambda, mu_police, s_police, mu_crisis, s_crisis)
for(lambda in lam){
for(p12 in p){
for(mu_police in mu_T){
for(mu_crisis in mu_M){
for(s_police in s_T){
for(s_crisis in s_M){
# which function is used to
p <- 1 - p12
#xy_inf[[i]] <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,13, TRUE)
xy_max7[[i]] <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,7+s_crisis, FALSE)
xy_max3[[i]] <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,3+s_crisis, FALSE)#(c_p,c_aux,mu_p, mu_aux, lambda, p, K=13)
xy_max1[[i]] <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,1+s_crisis, FALSE)
i <- i + 1
}
}
}
}
}
}
#results <- solve_PRM2b(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p12, 41) # alpha, L_P_q,L_A_q, W_P_q, W_A_q
xy_inf <- do.call(rbind, xy_inf)
xy_max7 <- do.call(rbind, xy_max7)
xy_max3 <- do.call(rbind, xy_max3)
xy_max1 <- do.call(rbind, xy_max1)
#output_file <- "IISE 2024 paper/PRM_2bGREEN_Results_INF.csv"
#write.csv(xy_inf, file = output_file, row.names = FALSE)
output_file <- "IISE 2024 paper/PRM_2bGREEN_Results_max7.csv"
write.csv(xy_max7, file = output_file, row.names = FALSE)
output_file <- "IISE 2024 paper/PRM_2bGREEN_Results_max3.csv"
write.csv(xy_max3, file = output_file, row.names = FALSE)
output_file <- "IISE 2024 paper/PRM_2bGREEN_Results_max1.csv"
write.csv(xy_max1, file = output_file, row.names = FALSE)
library(AuxiliaryQueue)
detach("package:AuxiliaryQueue", unload = TRUE)
install_github("vmwhite/auxqueue")
####### Parameters ranges <-  c(avg, min, max) #########
# Percentage of calls that require multiple response
n <- 	0.6019791
# average numer of cars in multiple response
avg_cars <-3.116467
# number of police servers
s_T <- list(400, 300, 450)
s_T <- lapply(s_T, function(x) round(x  /(avg_cars*n + (1-n))))
# TEST way lower number to see delay trends
s_T <- c(s_T,list(50, 70, 100))
# Arrival Rate (calls / hour)
lam <- list(33.798, 27.966, 41.052)
# Percentage of calls that are crisis calls
p <- list(0.0344,	0.0288,	0.039)
# Police Service Time (calls /hour)
mu_T <- list(0.582, 0.558, 0.654)
# Crisis Service Time (calls /hour)
mu_M <- list(0.588,	0.558,	0.618)
# number of crisis servers
s_M <- list(5,	3,	15)
# number of tests
N <- length(lam) * length(p) * length(mu_T) * length(mu_M) * length(s_T) * length(s_M)
xy_inf <- vector("list", ceiling(N)) # create an empty list into which values are to be filled
xy_max7 <- vector("list", ceiling(N)) # create an empty list into which values are to be filled
xy_max3 <- vector("list", ceiling(N)) # create an empty list into which values are to be filled
xy_max1 <- vector("list", ceiling(N)) # create an empty list into which values are to be filled
i <- 1
#append(i, lambda, mu_police, s_police, mu_crisis, s_crisis)
for(lambda in lam){
for(p12 in p){
for(mu_police in mu_T){
for(mu_crisis in mu_M){
for(s_police in s_T){
for(s_crisis in s_M){
# which function is used to
p <- 1 - p12
#xy_inf[[i]] <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,13, TRUE)
xy_max7[[i]] <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,7+s_crisis, FALSE)
xy_max3[[i]] <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,3+s_crisis, FALSE)#(c_p,c_aux,mu_p, mu_aux, lambda, p, K=13)
xy_max1[[i]] <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,1+s_crisis, FALSE)
i <- i + 1
}
}
}
}
}
}
library(AuxiliaryQueue)
detach("package:AuxiliaryQueue", unload = TRUE)
install_github("vmwhite\auxqueue")
install_github("vmwhite/auxqueue")
####### Parameters ranges <-  c(avg, min, max) #########
# Percentage of calls that require multiple response
n <- 	0.6019791
# average numer of cars in multiple response
avg_cars <-3.116467
# number of police servers
s_T <- list(400, 300, 450)
s_T <- lapply(s_T, function(x) round(x  /(avg_cars*n + (1-n))))
# TEST way lower number to see delay trends
s_T <- c(s_T,list(50, 70, 100))
# Arrival Rate (calls / hour)
lam <- list(33.798, 27.966, 41.052)
# Percentage of calls that are crisis calls
p <- list(0.0344,	0.0288,	0.039)
# Police Service Time (calls /hour)
mu_T <- list(0.582, 0.558, 0.654)
# Crisis Service Time (calls /hour)
mu_M <- list(0.588,	0.558,	0.618)
# number of crisis servers
s_M <- list(5,	3,	15)
# number of tests
N <- length(lam) * length(p) * length(mu_T) * length(mu_M) * length(s_T) * length(s_M)
xy_inf <- vector("list", ceiling(N)) # create an empty list into which values are to be filled
xy_max7 <- vector("list", ceiling(N)) # create an empty list into which values are to be filled
xy_max3 <- vector("list", ceiling(N)) # create an empty list into which values are to be filled
xy_max1 <- vector("list", ceiling(N)) # create an empty list into which values are to be filled
i <- 1
#append(i, lambda, mu_police, s_police, mu_crisis, s_crisis)
for(lambda in lam){
for(p12 in p){
for(mu_police in mu_T){
for(mu_crisis in mu_M){
for(s_police in s_T){
for(s_crisis in s_M){
# which function is used to
p <- 1 - p12
#xy_inf[[i]] <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,13, TRUE)
xy_max7[[i]] <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,7+s_crisis, FALSE)
xy_max3[[i]] <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,3+s_crisis, FALSE)#(c_p,c_aux,mu_p, mu_aux, lambda, p, K=13)
xy_max1[[i]] <- AuxiliaryQueue::auxqueue(s_police,s_crisis,  mu_police,  mu_crisis, lambda, p,1+s_crisis, FALSE)
i <- i + 1
}
}
}
}
}
}
